<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Malcev Normal Form For Heisenberg Group</title>
    <script src="http://cosmos.mat.uam.es/static/jquery.min.js"></script>
    <script src="http://cosmos.mat.uam.es/static/embedded_sagecell.js"></script>
    <script>$(function () {
    // Make the div with id 'mycell' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#mycell',
                           template:       sagecell.templates.minimal,
			hide:		['evalButton'],
			autoeval:	true,
                           evalButtonText: 'Activate'});
    });
    </script>
  </head>
  <body>

<div>
Type in a word in the 3-generated 2-step  Nilpotent group, $N_{3,2}$ generated by $a,b,c$, and commutators $d = [a,b], e = [a,c], f = [b,c]$. Words you enter MUST be written in $\{a,b,c,d,e,f,A,B,C,D,E,F\}^*$, where $A,B,C,D,E,F$ denote the inverses of $a,b,c,d,e,f$ respectively. The program will then output the Malcev normal form of the word you typed.
</div>
    <div id="mycell"><script type="text/x-sage">

#Written by Hang Lu Su, under the guidance of Moon Duchin and Andrew P. Sánchez.

#Make N_3,2 with generators a,b,c, d = [a,b], e = [a,c], f = [b,c]
F6.<a,b,c,d,e,f> = FreeGroup()
A, B, C, D, E, F = [x.inverse() for x in F6.gens()]

Relations = [a * b * A * B * D, 
     a * d * A * D,
     b * d * B * D, 
     c * d * C * D,

     a * c * A * C * E,
     a * e * A * E, 
     b * e * B * E,
     c * e * C * E,

     b * c * B * C * F,
     a * f * A * F, 
     b * f * B * F,
     c * f * C * F
     ]

N32 = F6 / Relations
a, b, c, d, e, f = N32.gens()
A, B, C, D, E, F = [x.inverse() for x in N32.gens()]

#-----
#FOR WEB INTERFACE
def element_of_string(s):
    """
    Transform string "aaBabbAAb" into group element.
    The element returned is the product a*a*B*a*b*b*A*A*b,
    it is not in Malcev normal form.
    """
    # make sure the input is a string representing an element
    # in G before evaluating
    if type(s) is not str:
        raise TypeError("Expected argument of type string.")
    if len(s) == sum(s.count(x) for x in 'abcdefABCDEF'):
        return reduce(lambda x,y: x*y, [eval(z) for z in s])
    raise ValueError("Argument of element_of_string should "
                     "be a string in characters abcdefABCDEF.")

#-----

#(list,int) -> boolean
def disorder_detected(syl,i):
    if str(syl[i][0]) == 'b' and str(syl[i+1][0]) == 'a' or \
    str(syl[i][0]) == 'c' and str(syl[i+1][0]) == 'a' or \
    str(syl[i][0]) == 'c' and str(syl[i+1][0]) == 'b': 
        return True
    else:
        return False

#list -> boolean
def index_to_fix(syl):
    for i in range(len(syl)-1):
        if disorder_detected(syl,i):
            return i
    return len(syl)

# (word, int) list -> int list
def retrieve_form(syl):
    form = []
    for i in range(len(syl)):
        form.append(syl[i][0])
    return form

#word list -> int list
def convert_to_integer_list(form):
    integer_list = []
    for generator in form:
        if str(generator) == 'a':
            integer_list.append(1)
        elif str(generator) == 'b':
            integer_list.append(2)
        elif str(generator) == 'c':
            integer_list.append(3)
        elif str(generator) == 'd':
            integer_list.append(4)
        elif str(generator) == 'e':
            integer_list.append(5)
        elif str(generator) == 'f':
            integer_list.append(6)

    return integer_list

#int list -> boolean
def is_list_in_order(integer_list): 
    for i in range(len(integer_list)-1):
        if integer_list[i] > integer_list[i+1]:
            return False
    return True

# (word, int) list -> boolean
def is_Malcified(syl):
    if len(syl) > 6:
        return False
    else:
        form = retrieve_form(syl)
        integer_list = convert_to_integer_list(form)
        return is_list_in_order(integer_list)

#list -> () [list got modified]
def collect_commutators(syl):
    new_syl = []
    commutator_counter = {d: 0, e: 0, f: 0}
    for i in range(len(syl)):
        if str(syl[i][0]) == 'd':
            commutator_counter[d] = commutator_counter[d] + syl[i][1]
        elif str(syl[i][0]) == 'e':
            commutator_counter[e] = commutator_counter[e] + syl[i][1]
        elif str(syl[i][0]) == 'f':
            commutator_counter[f] = commutator_counter[f] + syl[i][1]
        else:
            new_syl.append((syl[i]))

    new_syl.append((d,commutator_counter[d]))
    new_syl.append((e,commutator_counter[e]))
    new_syl.append((f,commutator_counter[f]))

    return new_syl

#list -> () [list got modified]
def apply_formula(syl,i):
    #b^y a^x = a^x b^y d^z, z = -xy
    #c^y a^x = a^x c^y e^z, z = -xy
    #c^y b^x = b^x c^y f^z, z = -xy 

    syllable_1 = syl.pop(i)
    syllable_2 = syl.pop(i)

    letter_1 = syllable_1[0]
    letter_2 = syllable_2[0]

    x = syllable_2[1]
    y = syllable_1[1]
    z = -x*y

    syl.insert(i,(letter_2,x))
    syl.insert(i+1,(letter_1,y))

    if str(letter_1)+str(letter_2) == 'ba':
        commutator = d
    elif str(letter_1)+str(letter_2) == 'ca':
        commutator = e
    elif str(letter_1)+str(letter_2) == 'cb':
        commutator = f

    syl.insert(i+2,(commutator,z))

#(word, int) list -> word
def reconstruct_from_syllables(syl):
    h = N32.one()
    for i in range(len(syl)):
        h = h*syl[i][0]^syl[i][1]
    return h

#(word, int) list -> word
def freely_reduce(syl):
    reduced_word = reconstruct_from_syllables(syl)
    syl = list(reduced_word.syllables())
    return syl

#word -> word
def Malcify(g): 
    syl = list(g.syllables())

    while (not is_Malcified(syl)):
        syl = freely_reduce(syl)
        syl = collect_commutators(syl)

        i = index_to_fix(syl) 
        if i < len(syl):
            apply_formula(syl,i)

    h = reconstruct_from_syllables(syl)
    return h


@interact
def _(word=input_box('bacab', type = str)):
  pretty_print("Malcev normal form: ")
  pretty_print(Malcify(element_of_string(str(word))))

 </script>
</div>
  </body>
</html>
