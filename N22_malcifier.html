<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Malcev Normal Form For Heisenberg Group</title>
    <script src="http://cosmos.mat.uam.es/static/jquery.min.js"></script>
    <script src="http://cosmos.mat.uam.es/static/embedded_sagecell.js"></script>
    <script>$(function () {
    // Make the div with id 'mycell' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#mycell',
                           template:       sagecell.templates.minimal,
			hide:		['evalButton'],
			autoeval:	true,
                           evalButtonText: 'Activate'});
    });
    </script>
  </head>
  <body>

<div>
Type in a word in the three-dimensional Heisenberg group generated by $a,b$, and commutator $c = [a,b]$. Words you enter MUST be written in $\{a,b,c,A,B,C\}^*$, where $A,B,C$ denote the inverses of $a,b,c$ respectively. The program will then output the Malcev normal form of the word you typed, in O(n) time.
</div>
    <div id="mycell"><script type="text/x-sage">

#LIST OF IMPLICIT ASSUMPTIONS
#1. In Malcifier(g), g is a word with a,b,c as generators.

#-----

#Make N_2,2 with generators a,b, c = [a,b]
F.<a,b,c> = FreeGroup()
A, B, C = [x.inverse() for x in F.gens()]

R = [a * b * A * B * C,
     a * c * A * C,
     b * c * B * C,
    ]

G = F / R
a, b, c = G.gens()
A, B, C = [x.inverse() for x in G.gens()]

#-----
#FOR WEB INTERFACE
def element_of_string(s):
    """
    Transform string "aaBabbAAb" into group element.
    The element returned is the product a*a*B*a*b*b*A*A*b,
    it is not in Malcev normal form.
    """
    # make sure the input is a string representing an element
    # in G before evaluating
    if type(s) is not str:
        raise TypeError("Expected argument of type string.")
    if len(s) == sum(s.count(x) for x in 'abcdeABCDE'):
        return reduce(lambda x,y: x*y, [eval(z) for z in s])
    raise ValueError("Argument of element_of_string should "
                     "be a string in characters abcdeABCDE.")

#-----

#(list,int) -> boolean
def ba_detected(syl,i):
    if str(syl[i][0]) == 'b' and str(syl[i+1][0]) == 'a':
        return True
    else:
        return False

def index_of_ba(syl):
    for i in range(len(syl)-1):
        if ba_detected(syl,i):
            return i
    return len(syl)

#list -> boolean
def is_not_Malcified(syl):
    if len(syl) > 3:
        return True
    elif len(syl) == 3:
        if str(syl[0][0]) == 'a' and str(syl[1][0]) == 'b' and \
        str(syl[2][0]) == 'c':
            return False
        else: 
            return True
    elif len(syl) == 2:
        if str(syl[0][0]) == 'a' and str(syl[1][0]) == 'b' or \
        str(syl[0][0]) == 'a' and str(syl[1][0]) == 'c' or \
        str(syl[0][0]) == 'b' and str(syl[1][0]) == 'c':
            return False
        else:
            return True
    elif len(syl) == 1:
        return False
    elif len(syl) == 0:
        return False
    else:
        return True

#list -> () [list got modified]
def move_c(syl):
    c_counter = 0
    indices_of_c = []
    for i in range(len(syl)):
        if str(syl[i][0]) == 'c':
            power_of_c = syl[i][1]
            syl.pop(i)
            syl.append((c,power_of_c))

#list -> () [list got modified]
def apply_formula(syl,i):
    #b^y a^x = a^x b^y c^z, z = -xy
    y = syl[i][1]
    x = syl[i+1][1]
    z = - x*y

    syl.pop(i)
    syl.insert(i,(a,x))

    syl.pop(i+1)
    syl.insert(i+1,(b,y))

    syl.insert(i+2,(c,z))

#list -> word
def reconstruct_from_syllables(syl):
    h = G.one()
    for i in range(len(syl)):
        h = h*syl[i][0]^syl[i][1]
    return h

#list -> word
def freely_reduce(syl):
    reduced_word = reconstruct_from_syllables(syl)
    syl = list(reduced_word.syllables())
    return syl

#word -> word
def Malcify(g): 
    syl = list(g.syllables())

    while is_not_Malcified(syl):
        syl = freely_reduce(syl)
        move_c(syl)

        i = index_of_ba(syl)
        if i < len(syl):
            apply_formula(syl,i)

    h = reconstruct_from_syllables(syl)
    return h

@interact
def _(word=input_box('abABc', type = str)):
  pretty_print("Malcev normal form: ")
  pretty_print(Malcify(element_of_string(str(word))))

 </script>
</div>
  </body>
</html>
